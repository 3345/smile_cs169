# Smile ^_^ Warmup Project

## Part 3: Backend

Last part of the warmup project!
Now you'll get to build your own server for the API and also hook it into your frontend app.

Task 0: Git branch structure
---

You will have to develop the backend in the same working tree that you used
for Part 1 and Part 2, so that you can submit your code to the same git
repository.

1. Create a local branch named `part3`, from your `part2` branch
```
git checkout -b part3
```

1. You will now be editing locally. If you need to move the files that you
    had for Part 2, feel free to do so. And **remember to commit frequently**. 

1. You will be deploying your application on Heroku.
   and you will have to submit
   the Heroku app URL to us. 
   See [Heroku Deployment](https://sites.google.com/site/ucbcs169fa15/project/setting-up-a-deployment-site)
   for more information on how to get started with the framework of your
   choice, and with Heroku. 
     - **Rails: To correctly set up the Rails project structure: ** Create a new rails
     application external to the Smile folder using `rails new <app name>`.
     Move the entire contents of the folder into the root of your repository
     folder. (such that the app/, db/ folders are on the same level as the
     original files in your Smile repo `smile_cs169/`) Treat this as your
     Rails application file now and follow the rest of the Heroku deployment
     instructions.
      - **Django: To correctly set up the Django project structure: ** Just
     follow the instructions from
     [Heroku: Getting Started with Django](https://devcenter.heroku.com/articles/getting-started-with-django)

After running `heroku create`, you should
   verify that you have the `heroku` remote added to your local git:
<!-- -->
```
git remote -v
```

You should see output of the form:
<!-- -->
```
heroku git@heroku.com:intense-mountain-1976.git (fetch)
heroku git@heroku.com:intense-mountain-1976.git (push)
origin         https://****/xx (fetch)
origin         https://****/xx (push)
```

where `intense-mountain-1976` is an example Heroku app name that Heroku will
create for you.

**Deploying the application to Heroku is a non-trivial
   step, do not leave it for the last minute.**

Task 1: Create the Model
---

You will have to get started using one of the backends that are approved
for this class. Check out that "Frameworks and Languages" page
on the class website.

You will have to create a single model, called Smile (or Smiles in Rails,
which cares a lot more about naming conventions). 

Your database schema should look like this (this is a suggestion, although
other schemas may work just as well):

| Field name       | Field type  | Constraints | Comments
---------------|-----|-----|-----
| id                      | integer        |   not null, primary key  | this should be autogenerated
| space                | string          |   not null (at most 128 characters) 
| title                   | string          |  not null (at most 64 characters)
| story                 | string          |    not null (at most 2048 characters)
| happiness_level  | integer       | not null
| like_count          | integer        |   not null
| created_at          | float            | not null | You can use some other representation of time , as long as it does not depend on the local timezone, and it allows for sub-second precision. 
| updated_at        | float             |  not null | You can use some other representation of time, as long as it does not depend on the local timezone, and it allows for sub-second precision. 

Task 2: Prepare the Automated Tests
---

Before you start writing the code for the API, I strongly recommend that you spend
some time getting the automated tests ready. We are giving you a very simple
test framework, written in Python, along with one automated test. The grading
of your project will be done with the same testing framework, except that we
will have a lot more tests. You too should add automated tests to the
framework. Writing automated tests, and experimenting with
running them against the backend we provide will familiarize you with
the more subtle corners of the API that you will have to implement. Plus,
these tests will allow you to test your own backend.
You will even be able to debug the corner cases of the API more easily
because the automated tests allow you to reproduce such a corner
case. For example, you may put a breakpoint in the debugger, and then
fire the specific automated test that you are trying to get right.

This development process is called **Test-Driven Development**.

The testing framework is provided to you in the `testing` directory:
* `testing/testLib.py`: this contains two classes, one which implements
    HTTP requests, and one that provides some helper functions for
    operating with smiles. You may want to add more helper functions
    to the `SmileTestCase` class.
    * By default, each test will first run the `setUp` method, defined
    in `testLib.SmileTestCase`. This method will **delete** all smile
    posts in the specified smile space. This is important, because
    you want all your tests to run in a predictable initial state.
    * Because of this, it is important to use a distinct smile space
    name from what other students will be using. All smiles in that
    space will be lost after running automated tests.
       
* `testing/testBarely.py`: this file contains one test cases, to serve as
    an example for you. You should write more test cases.
* `testing/runTests.sh`: this is a shell script that you can use to
   run the tests. You invoke the tests as follows:

   ```
   [VERBOSE=1] SMILE_SPACE=georges_private_space  TEST_SERVER=http://smileback-cs169.herokuapp.com testing/runTests.sh
    ```
    * This command will use the smile space `georges_private_Space` and will
      run against the server installed at
      `http://smileback-cs169.herokuapp.com`
    * If you use VERBOSE=1 you will see more detail about the messages that
      are sent/received.
    * To test against a local server use TEST_SERVER=http://127.0.0.1:8000
      (for Django running on port 8000)  
    * All those variables defined before the script name, are simply setting
      up environment variables. You can set the same variables in your
      current shell, and you do not need to pass them along each time.
    * You can specify a single test to run by adding the argument `testing.testBarely.TestSmiles.testAdd1`

Task 3: Create the Routes and Views
---

Once you have the automated tests ready, you can now proceed to write the code
for implementing the API.

You will have to implement the following API entry points:

1. GET /api/smiles
    - Read smiles. See specification in
      [Part 2](https://github.com/necula01/smile_cs169/tree/part2#get_smiles)

1. POST /api/smiles/:id/like
   - Increment the like_count for a smile.
      See specification in [Part 2](https://github.com/necula01/smile_cs169/tree/part2#post_like)

1. POST /api/smiles
   - Create a new smile.
      See specification in [Part 2](https://github.com/necula01/smile_cs169/tree/part2#post_create)

1. DELETE /api/smiles
    - Delete all the smiles in a smile space. See specification below.

<a name='delete_smiles'/>

DELETE /api/smiles
---
Gets the most recently updated smiles

##### Query Parameters
```
space: the name of the smile space to delete.
           (mandatory, non-empty, at most 128 characters) 
```

##### Example Request
```
DELETE /api/smiles?space=my_private_space
```

##### Example Response
The response contains a status field (with value 1 if there were no errors, and -1 if there were errors).
This is an example of a success response
```javascript
{
    "status" : 1
}
```

If there were errors, then the response contains only two fields:
```javascript
{
    "status" : -1,
    "errors" : [ ...list of error messages ... ]
}
```

The following error messages may be included for this request:
* "space must be non-empty" (if the submitted "space" is missing or empty
  string)


Task 4: Frontend Integration (Optional)
---

Now let's integrate the frontend you built in Part 1-2 into your application.
Users hitting the root route `/` on your server should be shown the
`index.html` page you built in Part 1 and 2.

You will have to change the `apiUrl` in `smiles.js` to be the empty string, to
ensure that the requests are sent to the same server from which the
`index.html` file is served.

You should be able to get this part working by adding a new route, and adding the HTML page as a view, and copying over the Javascript, CSS, and images.
You might need to adjust some routes depending on where assets and files are placed.

**Rails Advice: ** There are two ways to do add assets on Rails: 

1. **The hard, Rails convention way: ** Add a route for `index/`, create a
   controller that servers your static html file in the appropriate `views/`
   folder and make sure you remove any script `src=` or stylesheet `src=` in the
   file, and place your JS and CSS, and image assets into the assets folders
   `assets/javascripts` and `assets/stylesheets`, and `assets/images`
   respectively.
1. **The easy, anti-pattern way:** Put everything into the public folder.
   Install the gem `rails_12factor` in the production group so it will work on
   Heroku.


How to Submit
---

The deployment and submission steps for the backend are a bit more complex,
because you will need to deploy your code to Heroku as well as git.

1. You must deploy your application to Heroku before the deadline. You can
follow the standard Heroku instructions, with the exception of `git init` (as
explained in Task 0 above) and the exact command to push your local repo to
Heroku. Since you are using local branch `part3` you need to run the following
command to push changes to Heroku:
```
git push heroku part3:refs/heads/master
```
    - You can deploy multiple times to Heroku, after intermediate tasks, but on the deadline
      you need to have submitted the end result.
   
1. You must ensure that your site works. We
will be running automated tests on it. (Hint: try running the test yourself; there are no
excuses if the test we gave you is failing. Of course, we expect that you
would add more tests of your own.)

1. Watch Piazza and the class web site for the link to a form where you will
   have to submit the Heroku url to your project. 

1.  Commit your changes locally. Make sure you are in branch `part3`.

1. Push the `part3` branch to GitHub:
```
git push origin part3
```
   - You can submit multiple times, after intermediate tasks, but on the deadline
      you need to have submitted the end result.
   

You are Done!
---

We hope you are smiling ! Let's get ready for the real project now. 



