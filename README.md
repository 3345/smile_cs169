# Smile ^_^ Warmup Project

## Part 3: Backend

Last part of the warmup project!
Now you'll get to build your own server for the API and also hook it into your frontend app.


### Task 1: Create the Model
---

You will have to get started using one of the backends that are approved
for this class. Check out that "Frameworks and Languages" page
on the class website.

You will have to create a single model, called Smile (or Smiles in Rails,
which cares a lot more about naming conventions). 

Your database schema should look like this (this is a suggestion, although
other schemas may work just as well):

| Field name       | Field type  | Constraints | Comments
---------------|-----|-----|-----
| id                      | integer        |   not null, primary key  | this should be autogenerated
| space                | string          |   not null (at most 128 characters) 
| title                   | string          |  not null (at most 64 characters)
| story                 | string          |    not null (at most 2048 characters)
| happiness_level  | integer       | not null
| like_count          | integer        |   not null
| created_at          | float            | not null | You can use some other representation of time , as long as it does not depend on the local timezone, and it allows for sub-second precision. 
| updated_at        | float             |  not null | You can use some other representation of time, as long as it does not depend on the local timezone, and it allows for sub-second precision. 

.Task 2: Prepare the Automated Tests
---

Before you start writing the code for the API, I strongly recommend that you spend
some time getting the automated tests ready. We are giving you a very simple
test framework, written in Python, along with one automated test. The grading
of your project will be done with the same testing framework, except that we
will have a lot more tests. You too should add automated tests to the
framework. Writing automated tests, and experimenting with
running them against the backend we provide will familiarize you with
the more subtle corners of the API that you will have to implement. Plus,
these tests will allow you to test your own backend.
You will even be able to debug the corner cases of the API more easily
because the automated tests allow you to reproduce such a corner
case. For example, you may put a breakpoint in the debugger, and then
fire the specific automated test that you are trying to get right.

This development process is called **Test-Driven Development**.

The testing framework is provided to you in the `testing` directory:
* `testing/testLib.py`: this contains two classes, one which implements
    HTTP requests, and one that provides some helper functions for
    operating with smiles. You may want to add more helper functions
    to the `SmileTestCase` class.
    * By default, each test will first run the `setUp` method, defined
    in `testLib.SmileTestCase`. This method will **delete** all smile
    posts in the specified smile space. This is important, because
    you want all your tests to run in a predictable initial state.
    * Because of this, it is important to use a distinct smile space
    name from what other students will be using. All smiles in that
    space will be lost after running automated tests.
       
* `testing/testBarely.py`: this file contains one test cases, to serve as
    an example for you. You should write more test cases.
* `testing/runTests.sh`: this is a shell script that you can use to
   run the tests. You invoke the tests as follows:

   ```
   [VERBOSE=1] SMILE_SPACE=georges_private_space  TEST_SERVER=http://smileback-cs169.herokuapp.com testing/runTests.sh
    ```
    * This command will use the smile space `georges_private_Space` and will
      run against the server installed at
      `http://smileback-cs169.herokuapp.com`
    * If you use VERBOSE=1 you will see more detail about the messages that
      are sent/received.
    * To test against a local server use TEST_SERVER=http://127.0.0.1:8000
      (for Django running on port 8000)  
    * All those variables defined before the script name, are simply setting
      up environment variables. You can set the same variables in your
      current shell, and you do not need to pass them along each time.
    * You can specify a single test to run by adding the argument `testing.testBarely.TestSmiles.testAdd1`

.Task 3: Create the Routes and Views
---

Once you have the automated tests ready, you can now proceed to write the code
for implementing the API.

You will have to implement the following API entry points:

1. GET /api/smiles
    - Read smiles. See specification in
      [Part 2](https://github.com/necula01/smile_cs169/tree/part2#get_smiles)

1. POST /api/smiles/:id/like
   - Increment the like_count for a smile.
      See specification in [Part 2](https://github.com/necula01/smile_cs169/tree/part2#post_like)

1. POST /api/smiles
   - Create a new smile.
      See specification in [Part 2](https://github.com/necula01/smile_cs169/tree/part2#post_create)

1. DELETE /api/smiles
    - Delete all the smiles in a smile space. See specification below.

<a name='delete_smiles'/>
#### DELETE /api/smiles
---
Gets the most recently updated smiles

##### Query Parameters
```
space: the name of the smile space to delete.
           (mandatory, non-empty, at most 128 characters) 
```

##### Example Request
```
DELETE /api/smiles?space=my_private_space
```

##### Example Response
The response contains a status field (with value 1 if there were no errors, and -1 if there were errors).
This is an example of a success response
```javascript
{
    "status" : 1
}
```

If there were errors, then the response contains only two fields:
```javascript
{
    "status" : -1,
    "errors" : [ ...list of error messages ... ]
}
```

The following error messages may be included for this request:
* "space must be non-empty" (if the submitted "space" is missing or empty
  string)


### Task 4: Frontend Integration
---

Now let's integrate the frontend you built in Part 1-2 into your application.
Users hitting the root route `/` on your server should be shown the
`index.html` page you built in Part 1 and 2.

You will have to change the `apiUrl` in `smiles.js` to be the empty string, to
ensure that the requests are sent to the same server from which the
`index.html` file is served.

You should be able to get this part working by adding a new route, and adding the HTML page as a view, and copying over the Javascript, CSS, and images.
You might need to adjust some routes depending on where assets and files are placed.


### How to Submit
---

You will be deploying your application on Heroku and you will have to submit
the Heroku app URL to us. See [Heroku Deployment](https://sites.google.com/site/ucbcs169fa15/project/setting-up-a-deployment-site)
for more information.

You must ensure that your site works. We
will be running automated tests on it, using the smile space
"cs169-grading-space". (Hint: try running the test yourself; there are no
excuses if even the test we gave you is failing.)


.You are Done!
---

We hope you are smiling ! Let's get ready for the real project now. 



